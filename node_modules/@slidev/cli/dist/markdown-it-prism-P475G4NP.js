import {
  escapeVueInCode
} from "./chunk-6DS3IPOB.js";

// node/syntax/markdown-it/markdown-it-prism.ts
import { createRequire } from "node:module";
import Prism from "prismjs";
import loadLanguages from "prismjs/components/index.js";
import * as htmlparser2 from "htmlparser2";
var require2 = createRequire(import.meta.url);
var Tag = class {
  tagname;
  attributes;
  constructor(tagname, attributes) {
    this.tagname = tagname;
    this.attributes = attributes;
  }
  asOpen() {
    return `<${this.tagname} ${Object.entries(this.attributes).map(([key, value]) => `${key}="${value}"`).join(" ")}>`;
  }
  asClosed() {
    return `</${this.tagname}>`;
  }
};
var DEFAULTS = {
  plugins: [],
  init: () => {
  },
  defaultLanguageForUnknown: void 0,
  defaultLanguageForUnspecified: void 0,
  defaultLanguage: void 0
};
function loadPrismLang(lang) {
  if (!lang)
    return void 0;
  let langObject = Prism.languages[lang];
  if (langObject === void 0) {
    loadLanguages([lang]);
    langObject = Prism.languages[lang];
  }
  return langObject;
}
function loadPrismPlugin(name) {
  try {
    require2(`prismjs/plugins/${name}/prism-${name}`);
  } catch (e) {
    throw new Error(`Cannot load Prism plugin "${name}". Please check the spelling.`, { cause: e });
  }
}
function selectLanguage(options, lang) {
  let langToUse = lang;
  if (langToUse === "" && options.defaultLanguageForUnspecified !== void 0)
    langToUse = options.defaultLanguageForUnspecified;
  let prismLang = loadPrismLang(langToUse);
  if (prismLang === void 0 && options.defaultLanguageForUnknown !== void 0) {
    langToUse = options.defaultLanguageForUnknown;
    prismLang = loadPrismLang(langToUse);
  }
  return [langToUse, prismLang];
}
function highlight(markdownit, options, text, lang) {
  const [langToUse, prismLang] = selectLanguage(options, lang);
  let code = text.trimEnd();
  code = prismLang ? highlightPrism(code, prismLang, langToUse) : markdownit.utils.escapeHtml(code);
  code = code.split(/\r?\n/g).map((line) => `<span class="line">${line}</span>`).join("\n");
  const classAttribute = langToUse ? ` class="slidev-code ${markdownit.options.langPrefix}${markdownit.utils.escapeHtml(langToUse)}"` : "";
  return escapeVueInCode(`<pre${classAttribute}><code>${code}</code></pre>`);
}
function highlightPrism(code, prismLang, langToUse) {
  const openTags = [];
  const parser = new htmlparser2.Parser({
    onopentag(tagname, attributes) {
      openTags.push(new Tag(tagname, attributes));
    },
    onclosetag() {
      openTags.pop();
    }
  });
  code = Prism.highlight(code, prismLang, langToUse);
  code = code.split(/\r?\n/g).map((line) => {
    const prefix = openTags.map((tag) => tag.asOpen()).join("");
    parser.write(line);
    const postfix = openTags.reverse().map((tag) => tag.asClosed()).join("");
    return prefix + line + postfix;
  }).join("\n");
  parser.end();
  return code;
}
function checkLanguageOption(options, optionName) {
  const language = options[optionName];
  if (language !== void 0 && loadPrismLang(language) === void 0)
    throw new Error(`Bad option ${optionName}: There is no Prism language '${language}'.`);
}
function MarkdownItPrism(markdownit, useroptions) {
  const options = Object.assign({}, DEFAULTS, useroptions);
  checkLanguageOption(options, "defaultLanguage");
  checkLanguageOption(options, "defaultLanguageForUnknown");
  checkLanguageOption(options, "defaultLanguageForUnspecified");
  options.defaultLanguageForUnknown = options.defaultLanguageForUnknown || options.defaultLanguage;
  options.defaultLanguageForUnspecified = options.defaultLanguageForUnspecified || options.defaultLanguage;
  options.plugins.forEach(loadPrismPlugin);
  options.init(Prism);
  markdownit.options.highlight = (text, lang) => highlight(markdownit, options, text, lang);
}
export {
  MarkdownItPrism as default
};
